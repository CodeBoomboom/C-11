# 1. auto关键字

1、auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明

2、

```C++
int n = 20;
auto *p = &n, m = 99;
```

推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作`m=12.5`就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。

3、使用 auto 类型推导的变量必须马上初始化（auto只是占位符）

4、aut可以随意推导为任意的类型

```C++
int  x = 0;
auto *p1 = &x;   //p1 为 int *，auto 推导为 int
auto  p2 = &x;   //p2 为 int*，auto 推导为 int*
auto &r1  = x;   //r1 为 int&，auto 推导为 int
auto r2 = r1;    //r2 为  int，auto 推导为 int
```

5、auto推导为const类型时const属性会被抛弃，但是当其与引用结合时则不会抛弃const属性

```C++
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
```

6、auto 不能在函数的参数中使用。

​	这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。

7、auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。

8、auto 关键字不能定义数组，比如下面的例子就是错误的：

```C++
char url[] = "http://c.biancheng.net/";
auto  str[] = url;  //url为数组，所以不能使用 auto
```

9、auto 不能作用于模板参数，请看下面的例子：

```c++
template <typename T>
class A{
    //TODO:
};
int  main(){
    A<int> C1;
    A<auto> C2 = C1;  //错误
    return 0;
}
```

10、auto应用

（1）用于定义迭代器（迭代器名字太长）

注意：在STL的函数中使用auto类型时候要加*，如

```C++
set<int> myset;
for(auto i = 0; i<myset.size(); i++)
{
	if(myset.count(*i) == 1) break;	
}
```

（2）用于泛型编程

​	使用模板函数进行编程时若调用了其他不同类的同名函数，因为不知道函数返回的值的类型，先用auto接收，这样就避免了再使用一个模板函数参数。



# 2. decltype关键字

1、auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```c++
auto varname = value;
decltype(exp) varname = value;//varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式
decltype(exp) varname;//decltype也可以写成这样
```

auto 根据`=`右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系；

auto 要求变量必须初始化，而 decltype 不要求，这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了；

exp 是一个表达式，可以是任意复杂的形式，但它的结果必须是有类型的，不能是 void，否则会导致编译错误；

delctype用法示例：

```c++
int a = 0;

decltype(a) b = 1;  //b 被推导成了 int

decltype(10.8) x = 5.5;  //x 被推导成了 double

decltype(x + 100) y;  //y 被推导成了 double
```

2、exp

- 如果 exp 是一个不被括号`( )`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。

- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。

- 如果 exp 是一个左值，或者被括号`( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&

  左值和右值：左值是指那些**在表达式执行结束后依然存在的数据**，也就是持久性的数据；右值是指那些在表达式**执行结束后不再存在的数据**，也就是临时性的数据。有一种很简单的方法来区分左值和右值，**对表达式取地址，如果编译器不报错就为左值，否则为右值**。

```C++
//exp内为一般表达式#include <string>using namespace std;class Student{public:    static int total;    string name;    int age;    float scores;};int Student::total = 0;int  main(){    int n = 0;    const int &r = n;    Student stu;    decltype(n) a = n;  //n 为 int 类型，a 被推导为 int 类型    decltype(r) b = n;     //r 为 const int& 类型, b 被推导为 const int& 类型    decltype(Student::total) c = 0;  //total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型    decltype(stu.name) url = "http://c.biancheng.net/cplus/";  //total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型    return 0;}
```

```c++
//exp内为函数调用，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。//函数声明int& func_int_r(int, char);  //返回值为 int&int&& func_int_rr(void);  //返回值为 int&&int func_int(double);  //返回值为 intconst int& fun_cint_r(int, int, int);  //返回值为 const int&const int&& func_cint_rr(void);  //返回值为 const int&&//decltype类型推导int n = 100;decltype(func_int_r(100, 'A')) a = n;  //a 的类型为 int&decltype(func_int_rr()) b = 0;  //b 的类型为 int&&decltype(func_int(10.5)) c = 0;   //c 的类型为 intdecltype(fun_cint_r(1,2,3))  x = n;    //x 的类型为 const int &decltype(func_cint_rr()) y = 0;  // y 的类型为 const int&&
```

```c++
//exp为左值或被()包围using namespace std;class Base{public:    int x;};int main(){    const Base obj;    //带有括号的表达式    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&。    //加法表达式    int n = 0, m = 0;    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&    return 0;}
```

3、delctype应用

推导类的非静态成员的类型

# 3. auto与decltype的区别

1、语法格式区别

语法区别详见前两节

- auto 根据`=`右边的初始值 value 推导出变量的类型；
- decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系。
- auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。这很容易理解，因为 auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。
- auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开；虽然 auto 的书写更加简洁，但 decltype 的使用更加灵活。

2、对cv限定符的处理

「cv 限定符」是 const 和 volatile 关键字的统称：

- const 关键字用来表示数据是只读的，也就是不能被修改；
- volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取（这点在嵌入式C++编程中尤为常见，在嵌入式编程中有些寄存器的值的改变不能被忽略）。

在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。**decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符**。

以下是 auto 关键字对 cv 限定符的推导规则：

- 如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
- 如果表达式的类型是指针或者引用，auto 将保留 cv 限定符

3、对引用的处理

decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。



# 4. C++返回值类型后置（跟踪返回值类型）

在泛型编程中，可能需要通过参数的运算来得到返回值的类型。C++返回值类型后置（跟踪返回值类型）语法就是将 decltype 和 auto 结合起来完成返回值类型的推导的。

```C++
//不使用C++返回值类型后置（跟踪返回值类型）语法template <typename R, typename T, typename U>R add(T t, U u){    return t+u;}int a = 1; float b = 2.0;auto c = add<decltype(a + b)>(a, b);
```

```C++
//使用C++返回值类型后置（跟踪返回值类型）语法template <typename T, typename U>auto add(T t, U u) -> decltype(t + u){    return t + u;}
```

```c++
//使用C++返回值类型后置（跟踪返回值类型）语法//函数声明int& foo(int& i);	//foo没有具体意思，一般用作一个变量或函数的代号float foo(float& f);template <typename T>auto func(T& val) -> decltype(foo(val)){    return foo(val);}
```

返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。





# 5. C++11对模板实例化中连续右尖括号>>的改进

在 C++98/03 的泛型编程中，模板实例化有一个很烦琐的地方，那就是连续两个右尖括号（>>）会被编译器解释成右移操作符，而不是模板参数表的结束（必须在两个右尖括号中间加个空格）。

```C++
//如以下代码会报错:error: '>>' should be '>>' within a nested template argument list Foo<A<int>>::type xx;template <typename T>struct Foo{      typedef T type;};template <typename T>class A{    // ...};int main(void){    Foo<A<int>>::type xx;  //编译出错    return 0;}
```

在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出`>>`是一个右移操作符还是模板参数表的结束标记（delimiter，界定符）。但是使用这个代码还是会有问题`Foo<100 >> 2> xx;`，应该加括号`Foo<(100 >> 2)> xx;`

# 6. C++11使用using定义别名（替代typedef）

在C++中可以通过 typedef 重定义一个类型：

```c++
typedef unsigned int uint_t;
```

被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：

```c++
void func(unsigned int);void func(uint_t); // error: redefinition
```

使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。

想象下面这个场景：

```c++
typedef std::map<std::string, int> map_int_t;// ...typedef std::map<std::string, std::string> map_str_t;// ...
```

我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。

因此，在 C++98/03 中往往不得不这样写：

```C++
template <typename Val>struct str_map{    	typedef std::map<std::string, Val> type;};// ...str_map<int>::type map1;// ...
```

一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。

**现在，在 C++11 中终于出现了可以重定义一个模板的语法**。请看下面的示例：

```C++
template <typename Val>using str_map_t = std::map<std::string, Val>;// ...str_map_t<int> map1;
```

这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。

实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：

```C++
// 重定义unsigned inttypedef unsigned int uint_t;using uint_t = unsigned int;// 重定义std::maptypedef std::map<std::string, int> map_int_t;using map_int_t = std::map<std::string, int>;
```

typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：

```C++
typedef void (*func_t)(int, int);
```

与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：

```c++
using func_t = void (*)(int, int);
```

从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。

下面再通过一个对比示例，看看**新的 using 语法是如何定义模板别名的**。

```C++
/* C++98/03 */template <typename T>struct func_t{    typedef void (*type)(T, T);};// 使用 func_t 模板func_t<int>::type xx_1;/* C++11 */template <typename T>using func_t = void (*)(T, T);// 使用 func_t 模板func_t<int> xx_2;
```

从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。

需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。

因此，下面这样写：

```C++
void foo(void (*func_call)(int, int));void foo(func_t<int> func_call); // error: redefinition
```

同样是无法实现重载的，func_t<int>只是 void(*)(int, int) 类型的等价物。

using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：**模板别名（alias template）**。

# 7. C++11支持函数模板的默认模板参数

在 [C++](http://c.biancheng.net/cplus/)98/03 标准中，类模板可以有默认的模板参数，如下：

```c++
template <typename T, typename U = int, U N = 0>struct Foo{	// ...};
```

但是却不支持函数的默认模板参数：

```c++
template <typename T = int>// error in C++98/03: default template argumentsvoid func(){    	// ...}
```

现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：

```c++
int main(void){    	func(); //T = int    	return 0;}
```

此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随`<>`来实例化。

函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。

这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：

```c++
template <typename R = int, typename U>		//R使用默认模板参数，U使用自动推导R func(U val){    return val;}int main(){    func(97);               // R=int, U=int，编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int    func<char>(97);         // R=char, U=int，手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int    func<double, int>(97);  // R=double, U=int，  func<double,int>(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导    return 0;}
```

**当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错**。





# 8. C++11在函数模板和类模板中使用可变参数

## 可变参数

**可变参数**：参数的个数和类型都可以是任意的。如printf()中的参数就是可变参数，可以接收任意个参数且参数类型可以不同，例： `printf("%d %c %f",10, 'A', 1.23);`。

通常将容纳多个参数的可变参数称为**参数包**。借助 format 字符串，printf() 函数可以轻松判断出参数包中的参数个数和类型。

下面的程序中，自定义了一个简单的可变参数函数：

```c++
#include <iostream>#include <cstdarg>//可变参数的函数void vair_fun(int count, ...)	//...就是参数包{    va_list args;    va_start(args, count);    for (int i = 0; i < count; ++i)    {        int arg = va_arg(args, int);        std::cout << arg << " ";    }    va_end(args);}int main(){    //可变参数有 4 个，分别为 10、20、30、40    vair_fun(4, 10, 20, 30,40);    return 0;}
```

程序中的 vair_fun() 函数有 2 个参数，一个是 count，另一个就是 ... 可变参数。我们可以很容易在函数内部使用 count 参数，但要想使用参数包中的参数，需要借助`<cstdarg>`头文件中的 va_start、va_arg 以及 va_end 这 3 个带参数的宏：

- va_start(args, count)：args 是 va_list 类型的变量，我们可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；
- va_arg(args, int)：调用 va_start 找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回；
- va_end(args)：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。

注意，借助 va_arg 获取参数包中的参数时，va_arg 不具备自行终止的能力，所以程序中借助 count 参数控制 va_arg 的执行次数，继而将所有的参数读取出来。控制 va_arg 执行次数还有其他方法，比如读取到指定数据时终止。

使用 ... 可变参数的过程中，需注意以下几点：

1. ... 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数。
2. 可变参数的前面至少要有 1 个有名参数（例如上面例子中的 count 参数）；
3. 当可变参数中包含 char 类型的参数时，va_arg 宏要以 int 类型的方式读取；当可变参数中包含 short 类型的参数时，va_arg 宏要以 double 类型的方式读取。

## 可变参数模板

C++ 11 标准发布之前，函数模板和类模板只能设定固定数量的模板参数。C++11 标准对模板的功能进行了扩展，允许模板中包含任意数量的模板参数，这样的模板又称可变参数模板。

### 1）可变参数函数模板

```c++
template<typename... T>void vair_fun(T...args) {    //函数体}
```

模板参数中， **typename（或者 class）后跟 ... 就表明 T 是一个可变模板参数**，它可以接收多种数据类型，又称模板参数包。**vair_fun() 函数中，args 参数的类型用 T... 表示，表示 args 参数可以接收任意个参数，又称函数参数包。**

这也就意味着，此函数模板最终实例化出的 vair_fun() 函数可以指定任意类型、任意数量的参数。例如，我们可以这样使用这个函数模板：

```c++
vair_fun();vair_fun(1, "abc");vair_fun(1, "abc", 1.23);
```

使用可变参数模板的难点在于，如何在模板函数内部“解开”参数包（使用包内的数据）。

【递归方式解包】

```c++
#include <iostream>using namespace std;//模板函数递归的出口void vir_fun() {}template <typename T, typename... args>void vir_fun(T argc, args... argv){    cout << argc << endl;    //开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun    vir_fun(argv...);}int main(){    vir_fun(1, "xiaodexin", 2.34);    return 0;}
```

执行结果：

```
1xiaodexin2.34
```

- 首先，main() 函数调用 vir_fun() 模板函数时，根据所传实参的值，可以很轻易地判断出模板参数 T 的类型为 int，函数参数 argc 的值为 1，剩余的模板参数和函数参数都分别位于 args 和 argv 中；
- vir_fun() 函数中，首先输出了 argc 的值（为 1），然后重复调用自身，同时将函数参数包 argv 中的数据作为实参传递给形参 argc 和 argv（此时传给argc的为“xiaodexin”，传给argv的是2.34）；
- 再次执行 vir_fun() 函数，此时模板参数 T 的类型为 char*，输出 argc 的值为 "xiaodexin"。再次调用自身，继续将 argv 包中的数据作为实参（此时传给argc的为2.34，传给argv的为空）；
- 再次执行 vir_fun() 函数，此时模板参数 T 的类型为 double，输出 argc 的值为 2.34。再次调用自身，将空的 argv 包作为实参；
- 由于 argv 包没有数据，此时会调用无任何形参、函数体为空的 vir_fun() 函数，最终执行结束。

**以递归方式解包，一定要设置递归结束的出口。例如本例中，无形参、函数体为空的 vir_fun() 函数就是递归结束的出口。**

【非递归方法解包】
借助逗号表达式和初始化列表，也可以解开参数包。

以 vir_fun() 函数为例，下面程序演示了非递归方法解包的过程：

```C++
#include <iostream>using namespace std;template <typename T>void dispaly(T t) {    cout << t << endl;}template <typename... args>void vir_fun(args... argv){    //逗号表达式+初始化列表    int arr[] = { (dispaly(argv),0)... };}int main(){    vir_fun(1, "http://www.biancheng.net", 2.34);    return 0;}
```

这里重点分析一下第 13 行代码，我们以`{ }`初始化列表的方式对数组 arr 进行了初始化， (display(argv),0)... 会依次展开为 (display(1),0)、(display("http://www.biancheng.net"),0) 和 (display(2.34),0)。也就是说，第 13 行代码和如下代码是等价的：

```C++
int arr[] = { (dispaly(1),0), (dispaly("http://www.biancheng.net"),0),(dispaly(2.34),0) };
```

可以看到，每个元素都是一个逗号表达式，以 (display(1), 0) 为例，它会先计算 display(1)，然后将 0 作为整个表达式的值返回给数组，因此 arr 数组最终存储的都是 0。arr 数组纯粹是为了将参数包展开，没有发挥其它作用。

### 2）可变参数类模板

C++11 标准中，类模板中的模板参数也可以是一个可变参数。C++ 11 标准提供的 typle 元组类就是一个典型的可变参数模板类，它的定义如下：

```c++
template <typename... Types>class tuple;
```

和固定模板参数的类不同，typle 模板类实例化时，可以接收任意数量、任意类型的模板参数，例如：

```c++
std:tuple<> tp0;std::tuple<int> tp1 = std::make_tuple(1);std::tuple<int, double> tp2 = std::make_tuple(1, 2.34);std::tuple<int, double, string> tp3 = std::make_tuple(1, 2.34, "http://www.biancheng.net");
```

如下是一个支持可变参数的类模板：

```c++
#include <iostream>//声明模板类demotemplate<typename... Values> class demo;//继承式递归的出口template<> class demo<> {};//以继承的方式解包template<typename Head, typename... Tail>class demo<Head, Tail...>    : private demo<Tail...>{public:    demo(Head v, Tail... vtail) : m_head(v), demo<Tail...>(vtail...) {        dis_head();    }    void dis_head() { std::cout << m_head << std::endl; }protected:    Head m_head;};int main() {    demo<int, float, std::string> t(1, 2.34, "xiaodexin");    return 0;}
```

程序的输出结果为：

```
xiaodeixn2.341
```

程序中，demo 模板参数中的 Tail 就是一个参数包，解包的方式是以“递归+继承”的方式实现的。具体来讲，demo<Head, Tail...> 类实例化时，由于其继承自 demo<Tail...> 类，因此父类也会实例化，一直递归至 Tail 参数包为空，此时会调用模板参数列表为空的 demo 模板类。





# 9. C++11 tuple元组

C++11引入了一种类模板tuple，最大的特点：实例化的对象可以存储任意数量、任意类型的数据。

例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。

## tuple的创建

tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：

```c++
#include <tuple>using std::tuple;
```

实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。

### 1）构造函数

```
1) 默认构造函数constexpr tuple();2) 拷贝构造函数tuple (const tuple& tpl);3) 移动构造函数tuple (tuple&& tpl);4) 隐式类型转换构造函数template <class... UTypes>    tuple (const tuple<UTypes...>& tpl); //左值方式template <class... UTypes>    tuple (tuple<UTypes...>&& tpl);      //右值方式5) 支持初始化列表的构造函数explicit tuple (const Types&... elems);  //左值方式template <class... UTypes>    explicit tuple (UTypes&&... elems);  //右值方式6) 将pair对象转换为tuple对象template <class U1, class U2>    tuple (const pair<U1,U2>& pr);       //左值方式template <class U1, class U2>    tuple (pair<U1,U2>&& pr);            //右值方式
```

举例：

```c++
#include <iostream>     // std::cout#include <tuple>        // std::tupleusing std::tuple;int main(){    std::tuple<int, char> first;                             // 1)   first{}    std::tuple<int, char> second(first);                     // 2)   second{}    std::tuple<int, char> third(std::make_tuple(20, 'b'));   // 3)   third{20,'b'}    std::tuple<long, char> fourth(third);                    // 4)的左值方式, fourth{20,'b'}    std::tuple<int, char> fifth(10, 'a');                    // 5)的右值方式, fifth{10.'a'}    std::tuple<int, char> sixth(std::make_pair(30, 'c'));    // 6)的右值方式, sixth{30,''c}    return 0;}
```



### 2）make_tuple函数

上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。

对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：

```c++
auto first = std::make_tuple (10,'a');   // tuple < int, char >const int a = 0; int b[3];auto second = std::make_tuple (a,b);     // tuple < int, int* >
```

程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。

## tuple常用函数

| 函数或类模板                     | 描 述                                                        |
| -------------------------------- | ------------------------------------------------------------ |
| tup1.swap(tup2) swap(tup1, tup2) | tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。 |
| get<num>(tup)                    | tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。 |
| tuple_size<type>::value          | tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。 |
| tuple_element<I, type>::type     | tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。 |
| forward_as_tuple<args...>        | args... 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args... 元素都是右值引用形式的。 |
| tie(args...) = tup               | tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args... 指定的左值变量。 |
| tuple_cat(args...)               | args... 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args... 指定的所有 tuple 对象内的元素。 |

tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、<、>、>=、<= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。

```c++
#include <iostream>#include <tuple>int main(){    int size;    //创建一个 tuple 对象存储 10 和 'x'    std::tuple<int, char> mytuple(10, 'x');    //计算 mytuple 存储元素的个数    size = std::tuple_size<decltype(mytuple)>::value;    //输出 mytuple 中存储的元素    std::cout << std::get<0>(mytuple) << " " << std::get<1>(mytuple) << std::endl;    //修改指定的元素    std::get<0>(mytuple) = 100;    std::cout << std::get<0>(mytuple) << std::endl;    //使用 makde_tuple() 创建一个 tuple 对象    auto bar = std::make_tuple("test", 3.1, 14);    //拆解 bar 对象，分别赋值给 mystr、mydou、myint    const char* mystr = nullptr;    double mydou;    int myint;    //使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替    std::tie(mystr, mydou, myint) = bar;    //std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值    //将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中    auto mycat = std::tuple_cat(mytuple, bar);    size = std::tuple_size<decltype(mycat)>::value;    std::cout << size << std::endl;    return 0;}
```

程序执行结果为：

```
10 x1005
```





# 10. C++11列表初始化（统一了初始化方式）

在 [C++](http://c.biancheng.net/cplus/)98/03 中的对象初始化方法有很多种，初始化列表、拷贝初始化、直接初始化等，但这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11提出了列表初始化（List-initialization）的概念

```c++
class Foo{public:    Foo(int) {}private:    Foo(const Foo &);};int main(void){    Foo a1(123);	//构造函数    Foo a2 = 123;  //error: 'Foo::Foo(const Foo &)' is private    Foo a3 = { 123 };	//列表初始化    Foo a4 { 123 };		//列表初始化    int a5 = { 3 };	//列表初始化    int a6 { 3 };	//列表初始化    return 0;}
```

在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。

a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。

这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。

a4 和 a6 的写法，是 C++98/03 所不具备的。**在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化，即在初始化时，`{}`前面的等于号是否书写对初始化行为没有影响。**

另外，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：

```c++
int* a = new int { 123 };double b = double { 12.12 };int* arr = new int[3] { 1, 2, 3 };
```

列表初始化还可以直接使用在函数的返回值上

```c++
struct Foo{    Foo(int, double) {}};Foo func(void){    return { 123, 321.0 };	//这里的 return 语句就如同返回了一个 Foo(123, 321.0)}
```





# 11.  C++11 lambda匿名函数

就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式

## lambda函数的定义

```c++
[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型{  函数体;};
```

其中各部分的含义分别为：

1）[外部变量方位方式说明符]
[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。

> 所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。

2） (参数)
和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

3） mutable
此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；

4）noexcept/throw()
可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。

5） -> 返回值类型
指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略`-> 返回值类型`。

6）函数体
和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，**还可以使用指定的外部变量以及全局范围内的所有全局变量**。

需要注意的是，**外部变量会受到以值传递还是以引用传递方式引入的影响**，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。

> 其中，外部变量方位方式说明符是定义 lambda 表达式时必须写的，而其他参数在不同的情况下可以省略。

比如，如下就定义了一个最简单的 lambda 匿名函数：

```c++
[]{}	//一个没有任何功能的lambda函数
```

## lambda匿名函数中的[外部变量]

对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。

| 外部变量格式      | 功能                                                         |
| ----------------- | ------------------------------------------------------------ |
| []                | 空方括号表示当前 lambda 匿名函数中不导入任何外部变量。       |
| [=]               | 只有一个 = 等号，表示以值传递的方式导入所有外部变量；        |
| [&]               | 只有一个 & 符号，表示以引用传递的方式导入所有外部变量；      |
| [val1,val2,...]   | 表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序； |
| [&val1,&val2,...] | 表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序； |
| [val,&val2,...]   | 以上 2 种方式还可以混合使用，变量之间没有前后次序。          |
| [=,&val1,...]     | 表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。 |
| [this]            | 表示以值传递的方式导入当前的 this 指针。                     |

>  注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。

【例 1】lambda 匿名函数的定义和使用。

```c++
#include <iostream>#include <algorithm>using namespace std;int main(){    int num[4] = {4, 2, 3, 1};    //对 a 数组中的元素进行排序    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );    for(int n : num){        cout << n << " ";    }    return 0;}
```

程序执行结果为：

```
1 2 3 4
```

程序第 9 行通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。

虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：

```c++
#include <iostream>using namespace std;int main(){    //display 即为 lambda 匿名函数的函数名    auto display = [](int a,int b) -> void{cout << a << " " << b;};    //调用 lambda 函数    display(10,20);    return 0;}
```

程序执行结果为：

```
10 20
```

