# auto关键字

1、auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明

2、

```C++
int n = 20;
auto *p = &n, m = 99;
```

推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作`m=12.5`就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。

3、使用 auto 类型推导的变量必须马上初始化（auto只是占位符）

4、aut可以随意推导为任意的类型

```C++
int  x = 0;
auto *p1 = &x;   //p1 为 int *，auto 推导为 int
auto  p2 = &x;   //p2 为 int*，auto 推导为 int*
auto &r1  = x;   //r1 为 int&，auto 推导为 int
auto r2 = r1;    //r2 为  int，auto 推导为 int
```

5、auto推导为const类型时const属性会被抛弃，但是当其与引用结合时则不会抛弃const属性

```C++
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
```

6、auto 不能在函数的参数中使用。

​	这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。

7、auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。

8、auto 关键字不能定义数组，比如下面的例子就是错误的：

```C++
char url[] = "http://c.biancheng.net/";
auto  str[] = url;  //url为数组，所以不能使用 auto
```

9、auto 不能作用于模板参数，请看下面的例子：

```c++
template <typename T>
class A{
    //TODO:
};
int  main(){
    A<int> C1;
    A<auto> C2 = C1;  //错误
    return 0;
}
```

10、auto应用

（1）用于定义迭代器（迭代器名字太长）

注意：在STL的函数中使用auto类型时候要加*，如

```C++
set<int> myset;
for(auto i = 0; i<myset.size(); i++)
{
	if(myset.count(*i) == 1) break;	
}
```

（2）用于泛型编程

​	使用模板函数进行编程时若调用了其他不同类的同名函数，因为不知道函数返回的值的类型，先用auto接收，这样就避免了再使用一个模板函数参数。



# decltype关键字

1、auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```c++
auto varname = value;
decltype(exp) varname = value;//varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式
decltype(exp) varname;//decltype也可以写成这样
```

auto 根据`=`右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系；

auto 要求变量必须初始化，而 decltype 不要求，这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了；

exp 是一个表达式，可以是任意复杂的形式，但它的结果必须是有类型的，不能是 void，否则会导致编译错误；

delctype用法示例：

```c++
int a = 0;

decltype(a) b = 1;  //b 被推导成了 int

decltype(10.8) x = 5.5;  //x 被推导成了 double

decltype(x + 100) y;  //y 被推导成了 double
```

2、exp

- 如果 exp 是一个不被括号`( )`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。
- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。
- 如果 exp 是一个左值，或者被括号`( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&

```C++
//exp内为一般表达式
#include <string>
using namespace std;

class Student{
public:
    static int total;
    string name;
    int age;
    float scores;
};

int Student::total = 0;

int  main(){
    int n = 0;
    const int &r = n;
    Student stu;

    decltype(n) a = n;  //n 为 int 类型，a 被推导为 int 类型
    decltype(r) b = n;     //r 为 const int& 类型, b 被推导为 const int& 类型
    decltype(Student::total) c = 0;  //total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型
    decltype(stu.name) url = "http://c.biancheng.net/cplus/";  //total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型

    return 0;
}
```

```c++
//exp内为函数调用，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。
//函数声明
int& func_int_r(int, char);  //返回值为 int&
int&& func_int_rr(void);  //返回值为 int&&
int func_int(double);  //返回值为 int

const int& fun_cint_r(int, int, int);  //返回值为 const int&
const int&& func_cint_rr(void);  //返回值为 const int&&

//decltype类型推导
int n = 100;
decltype(func_int_r(100, 'A')) a = n;  //a 的类型为 int&
decltype(func_int_rr()) b = 0;  //b 的类型为 int&&
decltype(func_int(10.5)) c = 0;   //c 的类型为 int

decltype(fun_cint_r(1,2,3))  x = n;    //x 的类型为 const int &
decltype(func_cint_rr()) y = 0;  // y 的类型为 const int&&
```

```c++
//exp为左值或被()包围
using namespace std;

class Base{
public:
    int x;
};

int main(){
    const Base obj;

    //带有括号的表达式
    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int
    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&。

    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int
    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&

    return 0;
}
```
3、delctype应用

推导类的非静态成员的类型

# auto与decltype的区别

1、语法格式区别

语法区别详见前两节

- auto 根据`=`右边的初始值 value 推导出变量的类型；
- decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系。
- auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。这很容易理解，因为 auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。
- auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开；虽然 auto 的书写更加简洁，但 decltype 的使用更加灵活。

2、对cv限定符的处理

「cv 限定符」是 const 和 volatile 关键字的统称：

- const 关键字用来表示数据是只读的，也就是不能被修改；
- volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取（这点在嵌入式C++编程中尤为常见，在嵌入式编程中有些寄存器的值的改变不能被忽略）。

在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。**decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符**。

以下是 auto 关键字对 cv 限定符的推导规则：

- 如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
- 如果表达式的类型是指针或者引用，auto 将保留 cv 限定符

3、对引用的处理

decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。



# C++返回值类型后置（跟踪返回值类型）

在泛型编程中，可能需要通过参数的运算来得到返回值的类型。C++返回值类型后置（跟踪返回值类型）语法就是将 decltype 和 auto 结合起来完成返回值类型的推导的。

```C++
//不使用C++返回值类型后置（跟踪返回值类型）语法
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t+u;
}
int a = 1; float b = 2.0;
auto c = add<decltype(a + b)>(a, b);
```

```C++
//使用C++返回值类型后置（跟踪返回值类型）语法
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u)
{
    return t + u;
}
```

```c++
//使用C++返回值类型后置（跟踪返回值类型）语法
//函数声明
int& foo(int& i);	//foo没有具体意思，一般用作一个变量或函数的代号
float foo(float& f);
template <typename T>
auto func(T& val) -> decltype(foo(val))
{
    return foo(val);
}
```

返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。





# C++11对模板实例化中连续右尖括号>>的改进

在 C++98/03 的泛型编程中，模板实例化有一个很烦琐的地方，那就是连续两个右尖括号（>>）会被编译器解释成右移操作符，而不是模板参数表的结束（必须在两个右尖括号中间加个空格）。

```C++
//如以下代码会报错:error: '>>' should be '>>' within a nested template argument list Foo<A<int>>::type xx;
template <typename T>
struct Foo
{
      typedef T type;
};

template <typename T>
class A
{
    // ...
};

int main(void)
{
    Foo<A<int>>::type xx;  //编译出错
    return 0;
}
```

在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出`>>`是一个右移操作符还是模板参数表的结束标记（delimiter，界定符）。但是使用这个代码还是会有问题`Foo<100 >> 2> xx;`，应该加括号`Foo<(100 >> 2)> xx;`

# C++11使用using定义别名（替代typedef）

在C++中可以通过 typedef 重定义一个类型：

```c++
typedef unsigned int uint_t;
```

被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：

```c++
void func(unsigned int);
void func(uint_t); // error: redefinition
```

使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。

想象下面这个场景：

```c++
typedef std::map<std::string, int> map_int_t;
// ...
typedef std::map<std::string, std::string> map_str_t;
// ...
```

我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。

因此，在 C++98/03 中往往不得不这样写：

```C++
template <typename Val>
struct str_map
{    
	typedef std::map<std::string, Val> type;
};
// ...
str_map<int>::type map1;
// ...
```

一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。

**现在，在 C++11 中终于出现了可以重定义一个模板的语法**。请看下面的示例：

```C++
template <typename Val>
using str_map_t = std::map<std::string, Val>;
// ...
str_map_t<int> map1;
```

这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。

实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：

```C++
// 重定义unsigned int
typedef unsigned int uint_t;
using uint_t = unsigned int;
// 重定义std::map
typedef std::map<std::string, int> map_int_t;
using map_int_t = std::map<std::string, int>;
```

typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：

```C++
typedef void (*func_t)(int, int);
```

与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：

```c++
using func_t = void (*)(int, int);
```

从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。

下面再通过一个对比示例，看看**新的 using 语法是如何定义模板别名的**。

```C++
/* C++98/03 */
template <typename T>
struct func_t
{
    typedef void (*type)(T, T);
};
// 使用 func_t 模板
func_t<int>::type xx_1;
/* C++11 */
template <typename T>
using func_t = void (*)(T, T);
// 使用 func_t 模板
func_t<int> xx_2;
```

从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。

需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。

因此，下面这样写：

```C++
void foo(void (*func_call)(int, int));
void foo(func_t<int> func_call); // error: redefinition
```

同样是无法实现重载的，func_t<int>只是 void(*)(int, int) 类型的等价物。

using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：**模板别名（alias template）**。


