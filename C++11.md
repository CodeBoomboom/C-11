# auto关键字

1、auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明

2、

```C++
int n = 20;
auto *p = &n, m = 99;
```

推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作`m=12.5`就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。

3、使用 auto 类型推导的变量必须马上初始化（auto只是占位符）

4、aut可以随意推导为任意的类型

```C++
int  x = 0;
auto *p1 = &x;   //p1 为 int *，auto 推导为 int
auto  p2 = &x;   //p2 为 int*，auto 推导为 int*
auto &r1  = x;   //r1 为 int&，auto 推导为 int
auto r2 = r1;    //r2 为  int，auto 推导为 int
```

5、auto推导为const类型时const属性会被抛弃，但是当其与引用结合时则不会抛弃const属性

```C++
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
```

6、auto 不能在函数的参数中使用。

​	这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。

7、auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。

8、auto 关键字不能定义数组，比如下面的例子就是错误的：

```C++
char url[] = "http://c.biancheng.net/";
auto  str[] = url;  //url为数组，所以不能使用 auto
```

9、auto 不能作用于模板参数，请看下面的例子：

```c++
template <typename T>
class A{
    //TODO:
};
int  main(){
    A<int> C1;
    A<auto> C2 = C1;  //错误
    return 0;
}
```

10、auto应用

（1）用于定义迭代器（迭代器名字太长）

注意：在STL的函数中使用auto类型时候要加*，如

```C++
set<int> myset;
for(auto i = 0; i<myset.size(); i++)
{
	if(myset.count(*i) == 1) break;	
}
```

（2）用于泛型编程

​	使用模板函数进行编程时若调用了其他不同类的同名函数，因为不知道函数返回的值的类型，先用auto接收，这样就避免了再使用一个模板函数参数。



# decltype关键字

1、auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```c++
auto varname = value;
decltype(exp) varname = value;//varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式
decltype(exp) varname;//decltype也可以写成这样
```

auto 根据`=`右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系；

auto 要求变量必须初始化，而 decltype 不要求，这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了；

exp 是一个表达式，可以是任意复杂的形式，但它的结果必须是有类型的，不能是 void，否则会导致编译错误；

delctype用法示例：

```c++
int a = 0;

decltype(a) b = 1;  //b 被推导成了 int

decltype(10.8) x = 5.5;  //x 被推导成了 double

decltype(x + 100) y;  //y 被推导成了 double
```

2、exp

- 如果 exp 是一个不被括号`( )`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。
- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。
- 如果 exp 是一个左值，或者被括号`( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&

```C++
//exp内为一般表达式
#include <string>
using namespace std;

class Student{
public:
    static int total;
    string name;
    int age;
    float scores;
};

int Student::total = 0;

int  main(){
    int n = 0;
    const int &r = n;
    Student stu;

    decltype(n) a = n;  //n 为 int 类型，a 被推导为 int 类型
    decltype(r) b = n;     //r 为 const int& 类型, b 被推导为 const int& 类型
    decltype(Student::total) c = 0;  //total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型
    decltype(stu.name) url = "http://c.biancheng.net/cplus/";  //total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型

    return 0;
}
```

```c++
//exp内为函数调用，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。
//函数声明
int& func_int_r(int, char);  //返回值为 int&
int&& func_int_rr(void);  //返回值为 int&&
int func_int(double);  //返回值为 int

const int& fun_cint_r(int, int, int);  //返回值为 const int&
const int&& func_cint_rr(void);  //返回值为 const int&&

//decltype类型推导
int n = 100;
decltype(func_int_r(100, 'A')) a = n;  //a 的类型为 int&
decltype(func_int_rr()) b = 0;  //b 的类型为 int&&
decltype(func_int(10.5)) c = 0;   //c 的类型为 int

decltype(fun_cint_r(1,2,3))  x = n;    //x 的类型为 const int &
decltype(func_cint_rr()) y = 0;  // y 的类型为 const int&&
```

```c++
//exp为左值或被()包围
using namespace std;

class Base{
public:
    int x;
};

int main(){
    const Base obj;

    //带有括号的表达式
    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int
    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&。

    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int
    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&

    return 0;
}
```

